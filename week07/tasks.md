## Задача 0
Да се реализират описаните по-долу класове и посочените за тях членове. Реализацията на член-функциите може да е както в тялото на класа, така и извън него.
 

Да се реализира клас Temperature, представяща статистика за температура на въздуха. Статистиката има три свойства — минимална, максимална и средна 
температура, които са цели числа. Представянето на тази информация в класа е по ваш избор. Да се реализират следните членове на Temperature:


 * Конструктор по подразбиране, който задава прогноза, в която минималната, максималната и средната температура са 12 градуса.

 * Конструктор Temperature(int min, int avg, int max), който задава минимална, средна и максимална температура. Той трябва да прави проверка дали минималната, средната и максималната температура са подредени в нестрого нарастващ ред. Ако конструкторът получи като аргументи невалидна статистика, тогава всички три температури да се инициализират с 12 градуса.

 * Константни член-функции GetMin(), GetAverage(), GetMax(), връщащи съответните свойства.

 * Константна член-функция GetAmplitude(), която връща температурната амплитуда, т.е. разликата между максималната и минималната температура.

* Шестте оператора за сравнение (==, !=, <, >, <= и >=), с които могат да се сравняват две прогнози. Считаме, че една статистика е “по-студена” (по-малка) от 
друга, ако:

    - максималната температура на първата е по-малка от максималната втората, или

    - имат равни максимални температури, но минималната на първата е по-малка от минималната на втората, или

    - ако и минималните и максималните температури са равни, то средната температура на първата е по-малка от средната температура на втората.


## Задача 1:
Да се реализира клас Forecast, която представя прогноза за температурата в дадено населено място. Прогнозата има две свойства — име на населеното място и статистика за температура. Името е символен низ, който може да е с произволна дължина. То трябва да се представи в класа като масив от символи (char), който се заделя динамично с използване на new и се освобождава с помощта на delete. Използването на класа класа std::string не е позволено. Статистиката за температурата трябва да е обект от тип Temperature. За класа Forecast да се реализират следните членове:

Голямата четворка. В нея конструкторът по подразбиране да задава като име на населеното място празния низ и инициализира статистиката за температурата с нули за трите свойства.

Конструктор Forecast(const char* Place, Temperature const& Temp), който задава съответните стойности на име на населено място и температура.

Константни функции GetPlace() и GetTemperature() връщащи съответно името на населеното място и статистика за температурата в него. Функцията GetPlace() не трябва да позволява промяна на името на населеното място.

Функция UpdateIfHotter(Forecast const& F), която обновява температурната прогноза на населеното място с дадената прогноза F, но само ако населеното място на прогнозата F съвпада, а температурата е “по-гореща” в смисъла на >. В противен случай, функцията не прави промяна.

Оператори << и >> за изход и вход от поток за класа Forecast

Демонстрирайте работата на класовете с измислени от вас данни.


## Задача 2
В настоящите особени времена всяка обществена институция има нужда от билетна система осигуряваща ред и дистанция при опашките за обслужване на клиенти. В тази връзка реализирайте следните класове:

class Ticket
трябва да пази информация за име (символен низ) и телефон (символен низ) на клиента, както и поредния му номер (уникално целочислено число)
реализирайте подходящи конструктор/деструктори и getter/setter методи
предефинирайте операторите за вход (>>) и изход(<<)
направете валидация името да съдържа само букви и интервали (' ') иначе да хвърля изключение invalid_argument
направете валидация телефонния номер да бъде 10 цифри иначе да хвърля изключение length_error
class Queue, който има следните функции
Queue(int size) - осигурява максималната дължина на опашката
int getTicket(const char* name, const char* phone) - който добавя нов билет в системата и връща поредния му номер, а ако е запълнен капацитета на опашката хвърля overflow_error;
да се предефинира оператора [], който спрямо поредния номер връща билета, с този номер; а ако няма намерен билет хвърля invalid_argument
Ticket next() - изважда следващия от опашката
bool empty() const
int getSize() const

## Задача 3
Форест решил да тръгне на преход в планината и за целта си взел раница от N литра, но иска да не му тежи повече М килограма. Помогнете му да си подреди багажа в раницата като реализирате следните класове:

class Item
има член-данни име, тегло и обем
Item(const char* label, double weight, double volume)
предефинирайте операторите ==, >, =
class Backpack
може да събира различни обекти от Item в определения обем и желаното тегло
Backpack(double volume, double maxWeight)
void add(const Item &item) - ако не може да се добави следващия предмет поради недостатъчен обем хвърлете VolumeOverflow (дефиниран от вас), а при тегло хвърлете WeightOverflow (дефиниран от вас)
int size()
double leftVolume()
double leftWeight()
предефинирайте оператора [], ако индекса е по-голям от текущия брой item-и хвърлете out_of_range