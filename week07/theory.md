## Практикум - Седминца07

# Обработка на изключения в C++ и Шаблони в C++

Едно от предимствата на C++ пред C е обработката на изключения. Изключения са аномалии по време на изпълнение или необичайни условия, които програмата среща по време на своето изпълнение. Има два типа изключения: а) Синхронни, б) Асинхронни (Напр.: които са извън контрола на програмата, повреда на диска и т.н.). C++ предоставя следните специализирани ключови думи за тази цел.
try: представлява блок от код, който може да изведе изключение.
catch: представлява блок от код, който се изпълнява, когато се хвърли конкретно изключение.
throw: Използва се за хвърляне на изключение. Също така се използва за изброяване на изключенията, които дадена функция хвърля, но не се справя сама.

## Защо е нужна обработката на изключения?
Следват основните предимства на обработката на изключения пред традиционната обработка на грешки.
1) Разделяне на кода за обработка на грешки от нормален код: В традиционните кодове за обработка на грешки винаги има условия за обработка на грешки. Тези условия и кодът за обработка на грешки се смесват с нормалния поток. Това прави кода по-малко четим и поддържаем. С блоковете try catch кодът за обработка на грешки става отделен от нормалния поток.

2) Функциите/Методите могат да обработват всякакви изключения, които изберат: Функцията може да хвърля много изключения, но може да избере да обработва някои от тях. Другите изключения, които се хвърлят, но не са уловени, могат да се обработват от повикващия. Ако обаждащият се избере да не ги хване, тогава изключенията се обработват от повикващия на обаждащия се.
В C++ функцията може да посочи изключенията, които хвърля, използвайки ключовата дума throw. Извикващият на тази функция трябва да обработва изключението по някакъв начин (или като го посочи отново, или го хване)

3) Групиране на типове грешки: В C++ както основни типове, така и обекти могат да бъдат хвърлени като изключение. Можем да създадем йерархия от обекти на изключения, да групираме изключения в пространства от имена или класове, да ги категоризираме според типове.

## C++ изключения:

При изпълнение на C++ код могат да възникнат различни грешки: грешки в кодирането, направени от програмиста, грешки поради неправилно въвеждане или други непредвидими неща.

Когато възникне грешка, C++ обикновено спира и генерира съобщение за грешка. Техническият термин за това е: C++ ще изведе изключение (изведе грешка).

## C++ try and catch:

Обработката на изключения в C++ се състои от три ключови думи: try, throw и catch:

Операторът try ви позволява да дефинирате блок от код, който да бъде тестван за грешки, докато се изпълнява.

Ключовата дума throw хвърля изключение, когато бъде открит проблем, което ни позволява да създадем персонализирана грешка.

Операторът catch ви позволява да дефинирате блок код, който да бъде изпълнен, ако възникне грешка в блока try.

Ключовите думи try and catch идват по двойки:

Използваме блока try, за да тестваме някакъв код: Ако променливата възраст е по-малка от 18, ние ще хвърлим изключение и ще го обработваме в нашия блок catch.

В блока catch ние хващаме грешката и правим нещо по въпроса. Инструкцията catch приема параметър: в нашия пример използваме променлива int (myNum) (защото хвърляме изключение от тип int в блока try (age)), за да изведем стойността на age.

Ако не се появи грешка (например, ако възрастта е 20 вместо 15, което означава, че ще бъде по-голяма от 18), блокът за хващане се пропуска:

## Обработка на изключения в C++

1) Следва прост пример за показване на обработката на изключения в C++. Резултатът от програмата обяснява потока на изпълнение на блоковете try/catch.

```C++
#include <iostream>
using namespace std;

int main()
{
int x = -1;

// Some code
cout << "Before try \n";
try {
	cout << "Inside try \n";
	if (x < 0)
	{
		throw x;
		cout << "After throw (Never executed) \n";
	}
}
catch (int x ) {
	cout << "Exception Caught \n";
}

cout << "After catch (Will be executed) \n";
return 0;
}

```
### Output: 
```
Before try
Inside try
Exception Caught
After catch (Will be executed)
```

2) Има специален блок за хващане, наречен 'catch all' catch(...), който може да се използва за улавяне на всички видове изключения. Например, в следната програма, int се хвърля като изключение, но няма блок catch за int, така че блокът catch(...) ще бъде изпълнен.

``` C++
#include <iostream>
using namespace std;

int main()
{
	try {
	throw 10;
	}
	catch (char *excp) {
		cout << "Caught " << excp;
	}
	catch (...) {
		cout << "Default Exception\n";
	}
	return 0;
}
```
### Output: 

```
Default Exception
```

3) Неявно преобразуване на типове не се случва за примитивни типове. Например, в следващата програма „a“ не се преобразува имплицитно в int

```C++
#include <iostream>
using namespace std;

int main()
{
	try {
	throw 'a';
	}
	catch (int x) {
		cout << "Caught " << x;
	}
	catch (...) {
		cout << "Default Exception\n";
	}
	return 0;
}

```
### Output: 
```
Default Exception
```

4) Ако се изведе изключение и не се хване никъде, програмата се прекратява необичайно. Например, в следната програма се хвърля char, но няма блок за улавяне, който да хване char.
```C++
#include <iostream>
using namespace std;

int main()
{
	try {
	throw 'a';
	}
	catch (int x) {
		cout << "Caught ";
	}
	return 0;
}

```
### Output: 
```
terminate called after throwing an instance of 'char'

This application has requested the Runtime to terminate it in an 
unusual way. Please contact the application's support team for 
more information.
```
Можем да променим това необичайно поведение при прекратяване, като напишем собствена неочаквана функция.
5) Изключение на производен клас трябва да бъде уловено преди изключение от базов клас.
6) Подобно на Java, библиотеката C++ има стандартен клас на изключения, който е базов клас за всички стандартни изключения. Всички обекти, хвърлени от компоненти на стандартната библиотека, са получени от този клас. Следователно всички стандартни изключения могат да бъдат уловени чрез улавяне на този тип.
7) За разлика от Java, в C++ всички изключения не са отметнати. Компилаторът не проверява дали изключение е уловено или не. Например в C++ не е необходимо да се посочват всички неуловени изключения в декларация на функция. Въпреки че това е препоръчителна практика. Например, следната програма се компилира добре, но в идеалния случай подписът на fun() трябва да изброява непроверени изключения.
```C++
#include <iostream>
using namespace std;

// This function signature is fine by the compiler, but not recommended.
// Ideally, the function should specify all uncaught exceptions and function
// signature should be "void fun(int *ptr, int x) throw (int *, int)"
void fun(int *ptr, int x)
{
	if (ptr == NULL)
		throw ptr;
	if (x == 0)
		throw x;
	/* Some functionality */
}

int main()
{
	try {
	fun(NULL, 0);
	}
	catch(...) {
		cout << "Caught exception from fun()";
	}
	return 0;
}
```
### Output: 
```
Caught exception from fun()
```

По-добър начин да напишете горния код.

```C++
#include <iostream>
using namespace std;

// Here we specify the exceptions that this function
// throws.
void fun(int *ptr, int x) throw (int *, int) // Dynamic Exception specification
{
	if (ptr == NULL)
		throw ptr;
	if (x == 0)
		throw x;
	/* Some functionality */
}

int main()
{
	try {
	fun(NULL, 0);
	}
	catch(...) {
		cout << "Caught exception from fun()";
	}
	return 0;
}

```
(Забележка: Използването на Dynamic Exception Specification е отхвърлено след C++11, една от причините може би защото може да прекрати произволно вашата програма. Това може да се случи, когато хвърлите изключение от друг тип, който не е споменат в динамичния спецификация на изключение, вашата програма ще се прекъсне сама, тъй като в този сценарий програмата извиква (индиректно) terminate() и което по подразбиране е извикване abort()).

### Output: 
```
Caught exception from fun()
```

8) В C++, try-catch блоковете могат да бъдат вложени. Също така, изключение може да бъде прехвърлено отново с помощта на „throw; ”

```C++
#include <iostream>
using namespace std;

int main()
{
	try {
		try {
			throw 20;
		}
		catch (int n) {
			cout << "Handle Partially ";
			throw; // Re-throwing an exception
		}
	}
	catch (int n) {
		cout << "Handle remaining ";
	}
	return 0;
}

```

### Output
```
Handle Partially Handle remaining
```

9) Когато се хвърли изключение, всички обекти, създадени вътре в обграждащия блок try, се унищожават, преди контролата да бъде прехвърлена към блока catch.

```C++
#include <iostream>
using namespace std;

class Test {
public:
	Test() { cout << "Constructor of Test " << endl; }
	~Test() { cout << "Destructor of Test " << endl; }
};

int main()
{
	try {
		Test t1;
		throw 10;
	}
	catch (int i) {
		cout << "Caught " << i << endl;
	}
}

```
### Output
```
Constructor of Test
Destructor of Test
Caught 10
```