# Практикум #3

## Какво научихме предния път?
- текстови файлове и работа с тях

## Бинарни файлове



### <i>DISCLAIMER: 
Всички функционалности показани за текстовите файлове са почти 
идентични с тези при бинарните - различното е начина, по който ще ги използваме и целите, които ще искаме да постигнем с тях. </i> 

### Основни концепции

```c++
#include <fstream>
```


Запис в бинарен файл

Стъпките за запис на данни във файл са следните:
- отваряне на файл, в режим на работа **ios::binary**
- запис във файла
- затваряне на файла

Записването на информация във файл става по следния начин:

```c++
std::ofstream myfile;

myfile.open("example.bin", std::ios::binary);

// След като файлът вече е отворен за запис,
// можем да записваме информация в двоичен вид

// Да кажем, че искаме да запишем числото 1234
int number = 1234;

```
Ще използваме метода WRITE за записване в бинарен файл, който приема два параметъра

**write(<адрес в паметта>, <брой битове>)**

С две думи - указвате адреса на вашия обект и в колко байта искате да запазите този обект в бинарния файл (обиккновено се взима размера на обекта като брой битове) 

``` c++
// обърнете внимание на синтаксиса!
myfile.write(...)

// Затваряне на файла

myfile.close();

// След изпълнението на кода, програмата ще създаде текстов файл с име example.bin, който човек не може да прочете :)
```


Четене от бинарен файл

Стъпките за "прочитане" (зареждане на информацията от файл) са аналогични:
- отваряне на файл, с режим на работа **ios::binary**
- четене на данни от файла
- затваряне на файла

Прочитането на информация от файл става по следния начин:

```c++
// Отваряне на файла 
// Използва се класът ifstream ( името идва от: input file stream ),
// който отваря файла с права за четене

std::ifstream myfile;

myfile.open("example.bin", std::ios::binary);

// След като файлът вече е отворен за четене,
// можем да зареждаме данните от файла в програмата:

int readNum;

std::cout << "The value of the number BEFORE reading is " << readNum << std::endl;

myfile.read(...);

std::cout << "The value of the number AFTER reading is " << readNum << std::endl;


// Затваряне на файла

myfile.close();

// След изпълнението на кода, програмата ще създаде текстов файл с име example.bin, който човек не може да прочете :)
```

**sizeof** struct

Знаем какво прави операторът sizeof при използването му върху променлива - дава ни броят байтове, които тя заема в паметта. Какво обаче се случва, когато го използваме върху непримитивни данни - като структури например?

sizeof върху някаква структура ни дава **броя байтове, които заемат всяка една от член данните в структурата + padding байтовете** (ще обясним за тях след малко). Може да си го представите така - вместо да казвате на всяка една член данна "това колко байта заема", го казвате на цялата структура, която действа като сума на всички тях. 

Какво представлява padding byte? 

```c++
struct X
{
    short s; /* 2 bytes */
             /* 2 padding bytes */
    int   i; /* 4 bytes */
    char  c; /* 1 byte */
             /* 3 padding bytes */
};

struct Y
{
    int   i; /* 4 bytes */
    char  c; /* 1 byte */
             /* 1 padding byte */
    short s; /* 2 bytes */
};

struct Z
{
    int   i; /* 4 bytes */
    short s; /* 2 bytes */
    char  c; /* 1 byte */
             /* 1 padding byte */
};

const int sizeX = sizeof(struct X); /* = 12 */
const int sizeY = sizeof(struct Y); /* = 8 */
const int sizeZ = sizeof(struct Z); /* = 8 */
```

**USEFUL TIP**: Подреждайте член данните си по големина на съответния тип от когото е всяка една от тях, за да може структурата да заема най-малко памет.